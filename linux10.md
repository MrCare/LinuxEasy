# Linux 系统管理

## 1. 进程管理

### 1.1 进程查看

简介：

- 进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占有一定的系统资源

进程管理内容

- 判断服务器健康状态

- 查看系统中所有进程

- 杀死进程

查看系统中所有进程

- `ps aux`    #查看系统进程，使用 BSD 操作系统格式 a-前台进程 x-后台进程 u-用户

- `ps -le`    #查看系统中所有进程，使用 Linux 标准命令格式

| COLUMN  | 解释                                                                                 |
| ------- | ---------------------------------------------------------------------------------- |
| USER    | 产生进程的用户                                                                            |
| PID     | 进程ID                                                                               |
| %CPU    | 占用CPU百分比                                                                           |
| %MEM    | 占用物理内存百分百                                                                          |
| VSZ     | 占用虚拟内存大小 KB                                                                        |
| RSS     | 占用实际物理内存大小 KB                                                                      |
| TTY     | 该进程是在哪个终端中运行的，其中 tty1-tty7代表本地控制台终端，tty1-tty6是本地的字符界面终端，tty7是图形终端，pts/0-255 代表虚拟终端 |
| STAT    | 进程状态 R 运行；S 睡眠；T 停止状态；s 包含子进程；+ 位于后台                                               |
| START   | 进程的启动时间                                                                            |
| TIME    | 进程占用 CPU 的运算时间，不是系统时间                                                              |
| COMMAND | 产生此进程的命令名                                                                          |

查看系统健康状态

`top` + 选项

| 选项        | 作用                  |
| --------- | ------------------- |
| `-d` + 秒数 | 制定top命令每隔几秒更新，默认是3秒 |

- 输出内容：(健康状态)
  
  - 第一行信息为任务队列信息 
  
  - 第二行为进程信息
  
  - 第三行为CPU信息
  
  - 第四行为物理内存信息
  
  - 第五行为 Swap 分区信息

| 第一行内容                              | 说明                                                  |
| ---------------------------------- | --------------------------------------------------- |
| 12:26:46                           | 系统当前时间                                              |
| up 1 day, 13:32                    | 系统运行时间                                              |
| 2 users                            | 当前登录了两个用户                                           |
| **load average: 0.00, 0.00, 0.00** | 系统在之前1min，5min，15min的平均负载，一般认为小于CPU核数时较小，反之系统就处于超负荷 |

| 第二行内容          | 说明                                   |
| -------------- | ------------------------------------ |
| Task: 95 total | 系统中的进程总数                             |
| 1 running      | 正在运行的进程数                             |
| 94 sleeping    | 睡眠的进程                                |
| 0 stopped      | 正在停止的进程                              |
| 0 zombie       | 僵尸进程，如果不是0，需要手工检查 ，可能是未完全停止的进程，或者卡死了 |

| 第三行内容          | 说明                                          |
| -------------- | ------------------------------------------- |
| Cpu(s): 0.1%us | 用户模式占用的CPU百分比                               |
| 0.1%sy         | 系统模式占用的CPU百分比                               |
| 0.0%ni         | 改变过去优先级用户进程占用的CPU百分比                        |
| **99.7%id**    | 空闲CPU的百分比                                   |
| 0.1%wa         | 等待输入/输出的进程占用CPU百分比                          |
| 0.0%hi         | 硬中断请求服务占用的百分比                               |
| 0.1%si         | 软中断请求服务占用的百分比                               |
| 0.0%st         | st(Steal time) 虚拟时间百分比，就是当有虚拟机时，虚拟CPU的时间百分百 |

| 第四行内容              | 说明            |
| ------------------ | ------------- |
| Mem: 625344k total | 物理内存的总量，单位 KB |
| 571504k used       | 已经使用的物理内存数量   |
| **53840k free**    | 空闲的物理内存数量     |
| 65800k buffers     | 缓冲内存数量        |

| 第五行内容               | 说明             |
| ------------------- | -------------- |
| Swap: 524280k total | 交换分区(虚拟内存)的总大小 |
| 0k used             | 已经使用的交互分区的大小   |
| 524280k free        | 空闲交换分区的大小      |
| 409280k cached      | 作为缓存的交互分区的大小   |

- `top` 的交互命令

| `Shift` + 命令 | 作用              |
| ------------ | --------------- |
| `m`          | 将进程按内存占用比排序     |
| `p`          | 按CPU使用率排序，默认为此项 |
| `n`          | 以 PID 排序        |
| 直接 `q`       | 退出top           |
| `？` or `h`   | 显示交互模式的帮助       |

查看进程树

- `pstree` + 选项

| 选项   | 作用        |
| ---- | --------- |
| `-p` | 显示进程的PID  |
| `-u` | 显示进程的所属用户 |

### 1.2 进程管理

终止进程

- `kill -l`    #查看可用的进程信号

- `kill -15` + 进程ID    #可以用`pstree -p` 查看

| 信号代号 | 信号名称    | 作用                                                         |
| ---- | ------- | ---------------------------------------------------------- |
| 1    | SIGHUP  | 让进程立即关闭，然后重新读取配置文件后重启                                      |
| 2    | SIGINT  | 终止前台进程，相当于`ctrl + c`                                       |
| 8    | SIGFPE  | 在发生致命的运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其他所有的算术的错误             |
| 9    | SIGKILL | 强制终止进程                                                     |
| 14   | SIGALRM | 时钟定时信号，计算的是实际时间或时钟时间，alarm函数使用该信号                          |
| 15   | SIGTERM | 正常结束进程的信号，kill命令的默认信号，有时如果进程已经发生问题，这个信号是无法正常终止进程的，我们才会尝试 9 |
| 18   | SIGCONT | 让暂停的进程恢复执行，本信号不能被阻断                                        |
| 19   | SIGSTOP | 暂停前台进程，相当于输入`ctrl + z`，本信号不能被阻断                            |

- `killall` + 选项 + 信号 + 进程名    #按照进程名杀死进程

| 选项   | 作用              |
| ---- | --------------- |
| `-i` | 交互式，询问是否要杀死某个进程 |
| `-I` | 忽略进程名的大小写       |

- `pkill` + 选项 + 信号 + 进程名    #按照进程名终止进程

| 特殊选项       | 作用        |
| ---------- | --------- |
| `-t` + 终端号 | 按照终端号踢出用户 |

按照终端号踢出用户

```bash
w    #使用w命令查询本机已经登录的用户
pkill -t -9 pts/1    #强制杀死从pts/1虚拟终端登录的进程
```

## 2. 工作管理

把进程放入后台执行

- 命令 + &    #放在后台继续执行

- 在命令进行时 `ctrl + z`    #放在后台并暂停

查看后台工作

- `jobs -l` 显示工作的PID
  - +代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作。- 号代表倒数第二个放入后台的工作

将后台暂停的工作恢复到前台执行

- `fg %` + 工作号    # %可以省略，但是注意工作号和PID的区别

将后台暂停的工作恢复到后台执行

- `bg %` + 工作号

## 3. 系统资源查看

vmstat监控系统资源 (same as `top`)

- `vmstat` + 刷新延迟 + 刷新次数

- eg：
  
  - vmstat 1 3

dmesg开机时内核检测信息

- `dmesg`    #在开机状态下查看硬件信息

- `dmesg | grep CPU`

free命令查看内存使用状态

- `free` + 选项

| 选项   | 作用             |
| ---- | -------------- |
| `-b` | 以Byte为单位显示     |
| `-k` | 以KB为单位显示，默认为此项 |
| `-m` | 以MB显示          |
| `-g` | 以GB显示          |

- 缓存(cache)和缓冲(buffer)的区别
  
  - cache：加速数据从硬盘中的读取
  
  - buffer：用来加速数据写入硬盘的

查看 CPU 信息

- `cat/proc/cpuinfo` 查看 CPU 信息    #储存在内存中，断电后信息消失

uptime命令

- `uptime`
  
  - 显示系统的启动时间和平均负载，就是`top`命令的第一行，w命令也可以看到这个数据

查看系统与内核相关信息

- `uname` + 选项

| 选项   | 作用         |
| ---- | ---------- |
| `-a` | 查看系统所有相关信息 |
| `-r` | 查看内核版本     |
| `-s` | 查看内核名称     |

判断当前系统位数

- `file /bin/ls` 查看文件类型操作    #查询系统自带的命令的文件类型就可以

查询当前 LInux 系统发行版本

- `lsb_release -a`

列出进程打开或使用的文件信息

- `lsof` + 选项

| 选项         | 作用                |
| ---------- | ----------------- |
| `-c` + 字符串 | 只列出以字符串开头的进程打开的文件 |
| `-u` + 用户名 | 只列出某个用户的进程打开的文件   |
| `-p` + PID | 列出某个进程打开的文件       |

## 4. 系统定时任务

  crond 服务管理与访问控制 d：daemon 守护进程（守护神）

- `service crond restart` 服务重启

- `chkconfig crond on` 开启服务自启动

- `crontab` + 选项

| 选项   | 作用                   |
| ---- | -------------------- |
| `-e` | 编辑 crontab 定时任务      |
| `-l` | 查询 crontab 任务        |
| `-r` | 删除当前用户所有的 crontab 任务 |

- `crontab -e`

| 项目      | 含义         | 范围             |
| ------- | ---------- | -------------- |
| 第一个 `*` | 一小时当中的第几分钟 | 0-59           |
| 第二个 `*` | 一天当中的第几个小时 | 0-23           |
| 第三个 `*` | 一个月中的第几天   | 1-31           |
| 第四个 `*` | 一年中的第几个月   | 1-12           |
| 第五个 `*` | 一周中的星期几    | 0-7(0,7都代表星期日) |

| 特殊符号  | 含义      |
| ----- | ------- |
| `*`   | 代表任何时间  |
| `,`   | 分隔不连续时间 |
| `-`   | 连续时间范围  |
| `*/n` | 每隔n执行一次 |

eg：

| 时间                  | 含义                    |
| ------------------- | --------------------- |
| `45 22 * * *` + 命令  | 在22点45分执行命令           |
| `0 17 * * 1` + 命令   | 每周一的17点0分执行命令         |
| `0 5 1,15 * *` + 命令 | 每月1号和15号的5点0分执行命令     |
| `40 4 * * 1-5` + 命令 | 每周一到周五的凌晨4点40分执行命令    |
| `*/10 4 * * *` + 命令 | 每天4点到5点之间，每隔10分执行命令   |
| `0 0 1,15 * 1` + 命令 | 每月1号,15号,每周1的0点0分都会执行 |

- **在 定时任务中日期格式前的`%`必须加`\`,才可以使用系统时间，因为`%`在定时任务中有特殊含义！**

- eg：`/root/autobak.sh`

```bash
#!/bin/bash
#自动备份 /etc的脚本

date=$(date +\%y\%m\%d)    #查看当前系统时间
size=$(du -sh /etc)    #查看当前文件大小

echo "Date : $date" > /tmp/dbbak/dbinfo.txt
echo "Data size : $size" >> /tmp/dbbak/dbinfo.txt
cd /tmp/dbbak
tar -zcf etc_$date.tar.gz /etc /tmp/dbbak/dbinfo.txt &> /dev/null
rm -rf /tmp/dbbak/dbinfo.txt
#这个脚本的问题是应该先判断 dbinfo 是否存在，如果不存在需要新建
```

```bash
crontab -e
0 5 * * * /root/autobak.sh    #5点0分就会自动执行
```
